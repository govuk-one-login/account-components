import { type FastifyReply, type FastifyRequest } from "fastify";
import assert from "node:assert";
import {
  generateRegistrationOptions,
  MetadataService,
  verifyRegistrationResponse,
} from "@simplewebauthn/server";
import * as v from "valibot";
import { isoUint8Array } from "@simplewebauthn/server/helpers";
import { completeJourney } from "../../utils/completeJourney.js";
import { AccountDataApiClient } from "../../../utils/accountDataApiClient.js";
import { decodeAttestationObject } from "@simplewebauthn/server/helpers";
import { resolveEnvVarToBool } from "../../../../../commons/utils/resolveEnvVarToBool/index.js";

await MetadataService.initialize({
  verificationMode: resolveEnvVarToBool("IS_INTEGRATION_TEST")
    ? "permissive"
    : "strict",
  // TODO if we are using our own metadata service then change the config here appropriately
});

const render = async (reply: FastifyReply, options?: object) => {
  assert.ok(reply.render);

  await reply.render("journeys/passkey-create/templates/create.njk", options);
};

export async function getHandler(request: FastifyRequest, reply: FastifyReply) {
  assert.ok(request.session.claims);
  assert.ok(reply.journeyStates?.["passkey-create"]);
  assert.ok(process.env["PASSKEYS_RP_ID"]);
  assert.ok(process.env["PASSKEYS_RP_NAME"]);

  const registrationOptions = await generateRegistrationOptions({
    rpName: process.env["PASSKEYS_RP_NAME"],
    rpID: process.env["PASSKEYS_RP_ID"],
    userName: request.session.claims.email,
    // TODO is this the right value to use here? Do we need to specify
    // UserID at all or is the autogenerated one sufficient?
    userID: isoUint8Array.fromUTF8String(request.session.claims.public_sub),
    attestationType: "direct",
    authenticatorSelection: {
      userVerification: "required",
    },
  });

  reply.journeyStates["passkey-create"].send({
    type: "updateRegistrationOptions",
    registrationOptions,
  });

  await render(reply, {
    registrationOptions: JSON.stringify(registrationOptions),
  });
  return reply;
}

export async function postHandler(
  request: FastifyRequest,
  reply: FastifyReply,
) {
  assert.ok(request.session.claims);
  assert.ok(reply.journeyStates?.["passkey-create"]);

  const registrationOptions =
    reply.journeyStates["passkey-create"].getSnapshot().context
      .registrationOptions;
  assert.ok(registrationOptions);

  const bodySchema = v.object({
    error: v.optional(v.string()),
    registrationResponse: v.pipe(v.string(), v.parseJson()),
  });

  const bodyParseResult = v.safeParse(bodySchema, request.body);

  if (!bodyParseResult.success) {
    request.log.error(
      { issues: bodyParseResult.issues },
      "Register passkey - invalid request body",
    );
    // TODO go to error screen with radio buttons?
    return;
  }

  const body = bodyParseResult.output;

  if (body.error !== undefined) {
    request.log.error({ error: body.error }, "Register passkey - client error");
    // TODO go to error screen with radio buttons?
    return;
  }

  assert.ok(process.env["PASSKEYS_RP_ID"]);
  assert.ok(process.env["PASSKEYS_EXPECTED_ORIGIN"]);

  const verification = await verifyRegistrationResponse({
    // @ts-expect-error - the library's typing is too strict. This function
    // should accept any type for `response` because it is this function
    // which does the validation.
    response: body.registrationResponse,
    expectedChallenge: registrationOptions.challenge,
    expectedOrigin: process.env["PASSKEYS_EXPECTED_ORIGIN"],
    expectedRPID: process.env["PASSKEYS_RP_ID"],
  });

  if (!verification.verified) {
    request.log.error("Register passkey - verification failed");
    // TODO go to error screen with radio buttons?
    return;
  }

  assert.ok(request.session.claims.account_data_api_access_token);
  const accountDataApiClient = new AccountDataApiClient(
    request.session.claims.account_data_api_access_token,
    request.awsLambda?.event,
  );

  const decodedAttestation = decodeAttestationObject(
    verification.registrationInfo.attestationObject,
  );
  const attestationStatement = decodedAttestation.get("attStmt");
  const attestationSignature = attestationStatement.get("sig");

  const result = await accountDataApiClient.createPasskey(
    request.session.claims.public_sub,
    {
      credential: Buffer.from(
        verification.registrationInfo.credential.publicKey,
      ).toString("base64url"), // TODO base64url correct?
      id: verification.registrationInfo.credential.id,
      aaguid: verification.registrationInfo.aaguid,
      isAttested: attestationSignature !== undefined,
      signCount: verification.registrationInfo.credential.counter,
      transports: verification.registrationInfo.credential.transports ?? [],
      isBackedUp: verification.registrationInfo.credentialBackedUp,
      isBackUpEligible:
        verification.registrationInfo.credentialDeviceType === "multiDevice",
    },
  );

  if (!result.success) {
    throw new Error(result.error);
  }

  return await completeJourney(request, reply, {}, true);
}
