import { type FastifyReply, type FastifyRequest } from "fastify";
import assert from "node:assert";
import {
  generateRegistrationOptions,
  MetadataService,
  verifyRegistrationResponse,
} from "@simplewebauthn/server";
import * as v from "valibot";
import {
  checkValueForFormErrors,
  getFormErrorsList,
} from "../../../utils/formErrorsHelpers.js";
import { isoUint8Array } from "@simplewebauthn/server/helpers";
import { completeJourney } from "../../utils/completeJourney.js";
import { failedJourneyErrors } from "../../utils/failedJourneyErrors.js";
import { AccountDataApiClient } from "../../../utils/accountDataApiClient.js";
import { decodeAttestationObject } from "@simplewebauthn/server/helpers";
import { resolveEnvVarToBool } from "../../../../../commons/utils/resolveEnvVarToBool/index.js";

await MetadataService.initialize({
  verificationMode: resolveEnvVarToBool("IS_INTEGRATION_TEST")
    ? "permissive"
    : "strict",
  // TODO if we are using our own metadata service then change the config here appropriately
});

const render = async (reply: FastifyReply, options?: object) => {
  assert.ok(reply.render);

  await reply.render("journeys/passkey-create/templates/create.njk", options);
};

export async function getHandler(request: FastifyRequest, reply: FastifyReply) {
  assert.ok(request.session.claims);
  assert.ok(reply.journeyStates?.["passkey-create"]);
  assert.ok(process.env["PASSKEYS_RP_ID"]);
  assert.ok(process.env["PASSKEYS_RP_NAME"]);

  const registrationOptions = await generateRegistrationOptions({
    rpName: process.env["PASSKEYS_RP_NAME"],
    rpID: process.env["PASSKEYS_RP_ID"],
    userName: request.session.claims.email,
    // TODO is this the right value to use here? Do we need to specify
    // UserID at all or is the autogenerated one sufficient?
    userID: isoUint8Array.fromUTF8String(request.session.claims.public_sub),
    attestationType: "direct",
    authenticatorSelection: {
      userVerification: "required",
    },
  });

  reply.journeyStates["passkey-create"].send({
    type: "updateRegistrationOptions",
    registrationOptions,
  });

  await render(reply, {
    registrationOptions: JSON.stringify(registrationOptions),
  });
  return reply;
}

export async function postHandler(
  request: FastifyRequest,
  reply: FastifyReply,
) {
  assert.ok(request.session.claims);
  assert.ok(reply.journeyStates?.["passkey-create"]);

  const registrationOptions =
    reply.journeyStates["passkey-create"].getSnapshot().context
      .registrationOptions;
  assert.ok(registrationOptions);

  const bodySchema = v.object({
    registrationResponse: v.pipe(v.string(), v.parseJson()),
  });
  const bodyValidation = checkValueForFormErrors(request.body, bodySchema);

  if (!bodyValidation.success) {
    await render(reply, {
      errors: bodyValidation.formErrors,
      errorList: getFormErrorsList(bodyValidation.formErrors),
    });
    return reply;
  }

  const body = bodyValidation.parsedValue;

  assert.ok(process.env["PASSKEYS_RP_ID"]);
  assert.ok(process.env["PASSKEYS_EXPECTED_ORIGIN"]);

  const verification = await verifyRegistrationResponse({
    // @ts-expect-error - the library's typing is too strict. This function
    // should accept any type for `response` because it is this function
    // which does the validation.
    response: body.registrationResponse,
    expectedChallenge: registrationOptions.challenge,
    expectedOrigin: process.env["PASSKEYS_EXPECTED_ORIGIN"],
    expectedRPID: process.env["PASSKEYS_RP_ID"],
  });

  if (!verification.verified) {
    request.log.error("Create passkey verification failed");
    assert.ok(request.session.claims);

    // TODO is this the right thing to do here or should we allow the user to try again?
    // If we allow the user to try again then the registration options should be regrenerated and resaved to the session to prevent replay attacks.
    // If this is the right thing to do then don't use userSignedOut. Add a specific error code
    // to failedJourneyErrors and also update the private API spec with this code.
    return await completeJourney(
      request,
      reply,
      {
        error: failedJourneyErrors.userSignedOut,
      },
      false,
    );
  }

  assert.ok(request.session.claims.account_data_api_access_token);
  const accountDataApiClient = new AccountDataApiClient(
    request.session.claims.account_data_api_access_token,
    request.awsLambda?.event,
  );

  const decodedAttestation = decodeAttestationObject(
    verification.registrationInfo.attestationObject,
  );
  const attestationStatement = decodedAttestation.get("attStmt");
  const attestationSignature = attestationStatement.get("sig");

  const result = await accountDataApiClient.createPasskey(
    request.session.claims.public_sub,
    {
      credential: Buffer.from(
        verification.registrationInfo.credential.publicKey,
      ).toString("base64url"), // TODO base64url correct?
      id: verification.registrationInfo.credential.id,
      aaguid: verification.registrationInfo.aaguid,
      isAttested: attestationSignature !== undefined,
      signCount: verification.registrationInfo.credential.counter,
      transports: verification.registrationInfo.credential.transports ?? [],
      isBackedUp: verification.registrationInfo.credentialBackedUp,
      isBackUpEligible:
        verification.registrationInfo.credentialDeviceType === "multiDevice",
    },
  );

  if (!result.success) {
    throw new Error(result.error);
  }

  return await completeJourney(request, reply, {}, true);
}
